/**
 * AutoFix Generators
 * Gera conteúdo para AutoFixTask (templates, patches, comandos, etc.)
 */

import fs from 'fs';
import path from 'path';

/**
 * Templates para arquivos comuns
 */
const FILE_TEMPLATES = {
  'firestore.rules': `rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}`,
  
  'package.json': (projectName = 'project') => `{
  "name": "${projectName}",
  "version": "1.0.0",
  "description": "",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \\"Error: no test specified\\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {},
  "devDependencies": {}
}`,
  
  'README.md': (projectName = 'Project') => `# ${projectName}

## Descrição

Descrição do projeto.

## Instalação

\`\`\`bash
npm install
\`\`\`

## Uso

\`\`\`bash
npm start
\`\`\`

## Desenvolvimento

\`\`\`bash
npm test
\`\`\`
`,
  
  '.eslintrc.json': `{
  "env": {
    "browser": true,
    "es2021": true,
    "node": true
  },
  "extends": "eslint:recommended",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "rules": {}
}`,
  
  '.gitignore': `node_modules/
dist/
build/
.env
.DS_Store
*.log
`
};

/**
 * Gera template para arquivo faltando
 */
export function generateFileTemplate(filePath, issueType = 'default') {
  const fileName = path.basename(filePath);
  const fileExt = path.extname(filePath);
  
  // Template específico por nome de arquivo
  if (FILE_TEMPLATES[fileName]) {
    if (typeof FILE_TEMPLATES[fileName] === 'function') {
      const projectName = path.basename(path.dirname(filePath));
      return FILE_TEMPLATES[fileName](projectName);
    }
    return FILE_TEMPLATES[fileName];
  }
  
  // Template por extensão
  switch (fileExt) {
    case '.js':
    case '.jsx':
      return `// ${fileName}\n// Generated by Maestro Workflow\n\nexport default function() {\n  // Implementation\n}\n`;
    case '.ts':
    case '.tsx':
      return `// ${fileName}\n// Generated by Maestro Workflow\n\nexport default function(): void {\n  // Implementation\n}\n`;
    case '.json':
      return `{\n  "generated": true\n}\n`;
    case '.md':
      return `# ${fileName.replace(/\.md$/, '')}\n\n## Descrição\n\nConteúdo gerado automaticamente.\n`;
    default:
      return `// ${fileName}\n// Generated by Maestro Workflow\n`;
  }
}

/**
 * Extrai nome do pacote de mensagem de issue
 */
export function extractPackageName(message) {
  const patterns = [
    /package ['"]([^'"]+)['"]/i,
    /package ([^\s]+)/i, // "package express não encontrado"
    /npm install ([^\s]+)/i,
    /missing package: ([^\s]+)/i,
    /([@\w\/-]+) is not installed/i,
    /([@\w\/-]+) não encontrado/i // "express não encontrado"
  ];
  
  for (const pattern of patterns) {
    const match = message.match(pattern);
    if (match) {
      return match[1];
    }
  }
  
  return null;
}

/**
 * Gera comando para instalar dependência
 */
export function generateInstallCommand(packageName, location) {
  if (!packageName) {
    return null;
  }
  
  // Verificar se é package.json
  if (location && location.includes('package.json')) {
    return `npm install ${packageName}`;
  }
  
  return `npm install ${packageName}`;
}

/**
 * Extrai chave de configuração de mensagem
 */
export function extractConfigKey(message) {
  const patterns = [
    /config key: ([^\s]+)/i,
    /setting ['"]([^'"]+)['"]/i,
    /rule ['"]([^'"]+)['"]/i
  ];
  
  for (const pattern of patterns) {
    const match = message.match(pattern);
    if (match) {
      return match[1];
    }
  }
  
  return null;
}

/**
 * Extrai valor de configuração de mensagem
 */
export function extractConfigValue(message) {
  const patterns = [
    /should be ['"]([^'"]+)['"]/i,
    /set to ['"]([^'"]+)['"]/i,
    /value: ([^\s]+)/i
  ];
  
  for (const pattern of patterns) {
    const match = message.match(pattern);
    if (match) {
      return match[1];
    }
  }
  
  return 'true'; // Default
}

/**
 * Gera patch simples para adicionar import
 */
export function generateImportPatch(filePath, importStatement) {
  return {
    type: 'add',
    line: 1,
    content: `${importStatement}\n`
  };
}

/**
 * Determina se issue pode ser auto-fixável
 */
export function canBeAutoFixed(issue) {
  const message = (issue.message || '').toLowerCase();
  const type = (issue.type || '').toLowerCase();
  
  // Issues NÃO auto-fixáveis
  const nonAutoFixablePatterns = [
    'architecture',
    'arquitetura',
    'refactor',
    'business logic',
    'regra de negócio',
    'design decision',
    'decisão de design',
    'migrate',
    'migração',
    'rewrite',
    'reescrever'
  ];
  
  for (const pattern of nonAutoFixablePatterns) {
    if (message.includes(pattern) || type.includes(pattern)) {
      return false;
    }
  }
  
  // Issues auto-fixáveis
  const autoFixablePatterns = [
    'não encontrado',
    'não existe',
    'missing',
    'faltando',
    'not found',
    'does not exist',
    'package',
    'dependência',
    'dependency',
    'import',
    'config',
    'configuração',
    'documentation',
    'documentação',
    'test',
    'teste',
    'file',
    'arquivo'
  ];
  
  for (const pattern of autoFixablePatterns) {
    if (message.includes(pattern) || type.includes(pattern)) {
      return true;
    }
  }
  
  // Se tem location, provavelmente é auto-fixável
  if (issue.location) {
    return true;
  }
  
  return false;
}

/**
 * Determina targetType baseado em issue
 */
export function determineTargetType(issue) {
  const location = issue.location || '';
  const message = (issue.message || '').toLowerCase();
  
  if (location.includes('package.json') || message.includes('package') || message.includes('dependency')) {
    return 'command';
  }
  
  if (location.includes('.eslintrc') || location.includes('.prettierrc') || location.includes('config')) {
    return 'config';
  }
  
  if (location.includes('.md') || message.includes('documentation') || message.includes('readme')) {
    return 'doc';
  }
  
  if (message.includes('function') || message.includes('função')) {
    return 'function';
  }
  
  return 'file';
}

/**
 * Determina riskLevel baseado em issue
 */
export function determineRiskLevel(issue, fixType) {
  const severity = issue.severity || 'medium';
  const priority = issue.priority || 'P2';
  
  if (severity === 'critical' || priority === 'P0') {
    return 'high';
  }
  
  if (fixType === 'delete' || fixType === 'rewrite') {
    return 'medium';
  }
  
  if (fixType === 'create' || fixType === 'command') {
    return 'low';
  }
  
  return 'medium';
}

/**
 * Determina se requer aprovação
 */
export function determineRequiresApproval(issue, fixType) {
  const severity = issue.severity || 'medium';
  const priority = issue.priority || 'P2';
  
  // P0 sempre requer aprovação
  if (priority === 'P0' || severity === 'critical') {
    return true;
  }
  
  // Delete e rewrite sempre requerem aprovação
  if (fixType === 'delete' || fixType === 'rewrite') {
    return true;
  }
  
  // Create de arquivos importantes requer aprovação
  if (fixType === 'create') {
    const location = issue.location || '';
    if (location.includes('firestore.rules') || 
        location.includes('package.json') ||
        location.includes('.env')) {
      return true;
    }
  }
  
  return false;
}

export default {
  generateFileTemplate,
  extractPackageName,
  generateInstallCommand,
  extractConfigKey,
  extractConfigValue,
  generateImportPatch,
  canBeAutoFixed,
  determineTargetType,
  determineRiskLevel,
  determineRequiresApproval
};

